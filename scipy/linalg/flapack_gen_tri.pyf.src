! Signatures for f2py-wrappers of FORTRAN LAPACK General Tridiagonal Matrix functions.
!

subroutine <prefix>gtsv(n, nrhs, dl, d, du, b, info)
    callstatement (*f2py_func)(&n, &nrhs, dl, d, du, b, &n, &info);
    callprotoargument int*, int*, <ctype>*, <ctype>*, <ctype>*, <ctype>*, int*, int*
    integer intent(hide), depend(d) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = shape(b, 1)
    <ftype> dimension(n-1), intent(in,out,copy,out=du2), depend(d,n) :: dl
    <ftype> dimension(n), intent(in,out,copy) :: d
    <ftype> dimension(n-1), intent(in,out,copy), depend(n) :: du
    <ftype> dimension(n,nrhs), intent(in,out,copy,out=x), depend(n), check(shape(b,0)==n) :: b
    integer intent(out) :: info

end subroutine <prefix>gtsv

subroutine <prefix2>gtsvx(fact,trans,n,nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,iwork,info)
    ! ?GTSVX uses the LU factorization to compute the solution to a real
    ! system of linear equations A * X = B or A**T * X = B,
    ! where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
    ! matrices.
    !
    ! Error bounds on the solution and a condition estimate are also
    !provided.
    callstatement (*f2py_func)(fact,trans,&n,&nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,iwork,&info);
    callprotoargument char*,char*,int*,int*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,int*,<ctype2>*,int*,<ctype2>*,int*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,int*,int*

    character optional, intent(in), check(*fact=='F'||*fact=='N') :: fact = 'N'
    character optional, intent(in), check(*trans=='N'||*trans=='C'||*trans=='T') :: trans = 'N'
    integer intent(hide), depend(d), check(n > 1) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = max(1, shape(b, 1))
    <ftype2> intent(in), depend(n), dimension(n-1) :: dl
    <ftype2> intnet(in), dimension(n) :: d
    <ftype2> intent(in), depend(n), dimension(n-1) :: du
    <ftype2> optional, intent(in,out), depend(n), dimension(n-1) :: dlf
    <ftype2> optional, intent(in,out), depend(n), dimension(n) :: df
    <ftype2> optional, intent(in,out), depend(n), dimension(n-1) :: duf
    <ftype2> optional, intent(in,out), depend(n), dimension(n-2) :: du2
    integer optional, intent(in,out), depend(n), dimension(n) :: ipiv
    <ftype2> intent(in), dimension(ldb, nrhs) :: b
    integer intent(hide), depend(b), check(ldb >= n) :: ldb = max(1, shape(b, 0))
    <ftype2> dimension(n,nrhs),depend(n,nrhs),intent(out) :: x
    integer intent(hide), depend(n) :: ldx = n
    <ftype2> intent(out) :: rcond
    <ftype2> intent(out),dimension(nrhs),depend(nrhs) :: ferr
    <ftype2> intent(out),dimension(nrhs),depend(nrhs) :: berr
    <ftype2> dimension(3*n),depend(n),intent(hide,cache) :: work
    integer intent(hide,cache),dimension(n),depend(n) :: iwork
    integer intent(out) :: info

end subroutine <prefix2>gtsvx

subroutine <prefix2c>gtsvx(fact,trans,n,nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,rwork,info)
    ! ?GTSVX uses the LU factorization to compute the solution to a
    ! complex system of linear equations A * X = B or A**T * X = B,
    ! where A is a tridiagonal matrix of order N and X and B are N-by-NRHS
    ! matrices.
    !
    ! Error bounds on the solution and a condition estimate are also
    !provided.
    callstatement (*f2py_func)(fact,trans,&n,&nrhs,dl,d,du,dlf,df,duf,du2,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,rwork,&info);
    callprotoargument char*,char*,int*,int*,<ctype2c>*,<ctype2c>*,<ctype2c>*,<ctype2c>*,<ctype2c>*,<ctype2c>*,<ctype2c>*,int*,<ctype2c>*,int*,<ctype2c>*,int*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2c>*,<ctype2>*,int*

    character optional, intent(in), check(*fact=='F'||*fact=='N') :: fact = 'N'
    character optional, intent(in), check(*trans=='N'||*trans=='C'||*trans=='T') :: trans = 'N'
    integer intent(hide), depend(d), check(n > 1) :: n = len(d)
    integer intent(hide), depend(b) :: nrhs = max(1, shape(b, 1))
    <ftype2c> intent(in), depend(n), dimension(n-1) :: dl
    <ftype2c> intnet(in), dimension(n) :: d
    <ftype2c> intent(in), depend(n), dimension(n-1) :: du
    <ftype2c> optional, intent(in,out), depend(n), dimension(n-1) :: dlf
    <ftype2c> optional, intent(in,out), depend(n), dimension(n) :: df
    <ftype2c> optional, intent(in,out), depend(n), dimension(n-1) :: duf
    <ftype2c> optional, intent(in,out), depend(n), dimension(n-2) :: du2
    integer optional, intent(in,out), depend(n), dimension(n) :: ipiv
    <ftype2c> intent(in), dimension(ldb, nrhs) :: b
    integer intent(hide), depend(b), check(ldb >= n) :: ldb = max(1, shape(b, 0))
    <ftype2c> dimension(n,nrhs),depend(n,nrhs),intent(out) :: x
    integer intent(hide), depend(n) :: ldx = n
    <ftype2> intent(out) :: rcond
    <ftype2> intent(out),dimension(nrhs),depend(nrhs) :: ferr
    <ftype2> intent(out),dimension(nrhs),depend(nrhs) :: berr
    <ftype2c> dimension(2*n),depend(n),intent(hide,cache) :: work
    <ftype2> intent(hide,cache),dimension(n),depend(n) :: rwork
    integer intent(out) :: info

end subroutine <prefix2c>gtsvx
